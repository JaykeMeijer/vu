\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{todonotes}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{url}
\usepackage{graphicx}
\usepackage[all]{xy}
\usepackage{listings}
\usepackage[left=3cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\author{Rik van der Kooij: stdnummer, 2526314, VU-net-id: rkj800\\ \&  \\ Richard Torenvliet: stdnummer, 2526864 \ VU-net-id: rtt210}
\title{Concurrency \& Multithreading, concurrent datastructures}
\begin{document}
\maketitle
\tableofcontents

\section{Introduction}
This document is a follow up of the design document made earlier in this coarse. In the design document the idea of different types of synchronizing a concurrent datastructure where discussed and a hypotheses was made about the performance. In the following sections these hypotheses are proofen or disprooven.

\section{Testing}
The datastructures are tested with the shell file: \texttt{bin/test\_data\_structures.sh}. This script takes four parameters where the datastructes can be tested on.

\begin{figure}[h!]
\center
\begin{lstlisting}
test_data_structures <data_structure> <nrThreads> <nrItems> <workTime>
  where:
    <data_structure> in {cgl, cgt, fgl, fgt, lfl, lft}
    <nrThreads> is a number > 0
    <nrItems> is a number > 0
    <workTime> is a number >= 0 (micro seconds)
\end{lstlisting}
\caption{Executing data\_structures.sh}
\end{figure}

With all the datastructures these parameters are changed in order to draw conclusions about the performance. 

Every data structure is called in the following ranges.
\begin{lstlisting}
<cgl, cgt, fgl, fgt, lfl, lft
	nrThreads: 1, 2, 4, 8
	nrItems: 100, 1000, 10000, 100000, 1000000
	worktTime: 0
\end{lstlisting}

The number of threads, nritems are clear. The worktime is a number in microseconds a thread waits before adding the next element. If this number is 0 the threads do not wait before adding the next element what means that the contention is high. If the workload increases, the of chance of high contention decreases.

Next sections will discuss the list and tree datastructures. Because of the fact that the performance of a tree farly outstands the performance of the list.

\section{List performances}
\subsection{Coarse Grained}
The implementations of the concurrent list data structure all follow the pseudocode examples of the book\footnote{The Art of Multicoreprocessor Programming by Maurice Herliy \& Shavit - Chapter 9 Linked Lists: The Role of Locking}. The sorting by hash values of the examples has been changed to the Comparable<T> interface as the assignment requested. The pseudocode code was also changed to allow double elements.

We make use of two sentinel nodes head and tail. These are implemented as Node objects which override the compareTo method to always return -1 and 1 respectively. The debug toString method is nothing fancy. It prints the elements in the order they appear in the list with a space in between. The two sentinel nodes are not printed.

Locking is done as we explained in the design document. A single ReentrantLock is used. It is locked at the start of each add and remove method and unlocked at the end.

% \begin{figure}
% 	\includegraphics[scale=1]{} 
% \end{figure}
\subsection{Fine Grained}

\subsection{Lock Free}
Adding an element can be broken down to one pointer swap. If this is done atomically adding can then be done lock free. Removing is not that simple. No concurrent removals of two subsequent nodes is allowed. This means that atomically setting the next pointer when removing is not enough. We solve this by first marking the node we are removing. If we then make sure that marked nodes cannot change their next pointer, we safely remove the node. Because we have to mark and set a pointer atomically we use the AtomicMarkedReference class of Java.

The toSring method cannot be used for the lock free data structures when other threads are using the list. When we for instance get to a node it might be deleted concurrently. This means we include a removed Node.



\section{Tree performances}
\subsection{Coarse Grained}
The Coarse Grained Tree is a BST and is similarly locked as the Coarse Grained list version. To be able to make use of the head an tail nodes as starting 
\subsection{Fine Grained}

\subsection{Lock Free}
The lock free tree uses a leaf based tree. Adding a node will always add a leaf or a leaf and internal node. Removing will always remove a leaf and an internal node. This means that we can add a node to the lock free in 3 atomic steps and removing it in 4 atomic steps. The implementation makes uses of flags. Whenever an add or remove encounters a node with a flag it first tries to help it before trying its own operation. This can be done because every step stores enough information to finish the task.

Adding a node to the tree starts with finding which node to add it to, its parent. This node will be marked with an insert flag. We can than safely insert the node to the tree as a leaf and unmark the parent. 

Removing a nodes also starts with finding the node which has to be removed. We then mark the grandparent with a delete flag since one of its child pointers is going to change. The parent is marked with a marked flag which shows that it is going to be removed as well. The removing is then done in the grandparent by setting the appropriate child to the sibling of the removed node. We finish by unmarking the grandparent which allows new operations on the node.

For the toString method it's the same for the lock free tree. Elements we print might already be deleted or we might skip new elements which are added. We are therefore never sure the printed tree has ever really existed.


\subsection{conclusion}

\end{document}
